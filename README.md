# DevOps Project 2024

## üìë Table des mati√®res
1. [Introduction](#introduction)
2. [Pr√©requis](#pr√©requis)
3. [Installation](#installation)
4. [Les 7 Composants](#les-7-composants)
   - [Application Web](#1-application-web)
   - [CI/CD Pipeline](#2-cicd-pipeline)
   - [Infrastructure as Code](#3-infrastructure-as-code)
   - [Docker](#4-docker)
   - [Docker Compose](#5-docker-compose)
   - [Kubernetes](#6-kubernetes)
   - [Service Mesh avec Istio](#-7-service-mesh-avec-istio)
5. [Structure du Projet](#-structure-du-projet)
6. [Liens](#-liens)
7. [Auteurs](#-auteurs)

## üöÄ Introduction

Dans le cadre de notre formation √† l'ECE Paris, nous avons d√©velopp√© un projet DevOps complet qui met en ≈ìuvre les meilleures pratiques de l'industrie. Ce projet consiste en une API REST de gestion d'utilisateurs, construite avec Node.js et Redis, et d√©ploy√©e √† travers une cha√Æne DevOps compl√®te.

Notre objectif √©tait de cr√©er une application moderne qui d√©montre l'utilisation des technologies DevOps essentielles : du d√©veloppement au d√©ploiement, en passant par la conteneurisation et l'orchestration. Nous avons mis l'accent sur l'automatisation, la scalabilit√© et la maintenabilit√© du code.

## ‚ö° Pr√©requis

Pour ex√©cuter ce projet dans son int√©gralit√©, vous aurez besoin des √©l√©ments suivants install√©s sur votre machine :

- **Node.js (v14 ou sup√©rieur)**
  - Environnement d'ex√©cution JavaScript
  - npm pour la gestion des d√©pendances

- **Redis**
  - Base de donn√©es en m√©moire
  - Utilis√©e pour le stockage des donn√©es utilisateurs

- **Docker & Docker Compose**
  - Docker pour la conteneurisation
  - Docker Compose pour l'orchestration locale

- **Kubernetes (Minikube)**
  - Orchestrateur de conteneurs
  - Minikube pour le d√©veloppement local

- **Istio**
  - Service Mesh pour Kubernetes
  - Gestion avanc√©e du trafic

- **Vagrant & VirtualBox**
  - Vagrant pour la gestion des VM
  - VirtualBox comme hyperviseur

## üîß Installation

Nous avons con√ßu le processus d'installation pour √™tre aussi simple et automatis√© que possible. Voici les √©tapes d√©taill√©es :

1. **Cloner le repository**
   ```bash
   git clone https://github.com/Vincent23032003/devops-project-2024.git
   cd devops-project-2024
   ```
   Cette commande r√©cup√®re la derni√®re version du code depuis GitHub.

2. **Installer les d√©pendances**
   ```bash
   cd userapi
   npm install
   ```
   Cette √©tape installe toutes les d√©pendances Node.js n√©cessaires au projet.

3. **Lancer les tests**
   ```bash
   npm test
   ```
   Ex√©cute la suite compl√®te de tests pour v√©rifier que tout fonctionne correctement.

4. **API Endpoints**
   Notre API expose les endpoints suivants pour la gestion des utilisateurs :

   | M√©thode | Endpoint | Description | Exemple de payload |
   |---------|----------|-------------|-------------------|
   | GET | `/health` | V√©rifie l'√©tat de l'application | - |
   | GET | `/` | Page d'accueil avec documentation | - |
   | POST | `/users` | Cr√©er un utilisateur | `{"username": "john", "email": "john@example.com"}` |
   | GET | `/users/:id` | Obtenir les d√©tails d'un utilisateur | - |
   | PUT | `/users/:id` | Mettre √† jour un utilisateur | `{"email": "new.email@example.com"}` |
   | DELETE | `/users/:id` | Supprimer un utilisateur | - |

## üõ†Ô∏è Les 7 Composants

### 1. Application Web

Notre application web repr√©sente le c≈ìur du projet. Nous avons choisi des technologies modernes et robustes pour construire une API REST performante et facilement maintenable.

#### Technologies Utilis√©es

Nous avons s√©lectionn√© avec soin notre stack technologique :

- **Node.js et Express**
  - Framework web rapide et minimaliste
  - Support natif de l'asynchrone
  - Grande communaut√© et √©cosyst√®me riche

- **Redis**
  - Base de donn√©es en m√©moire ultra-rapide
  - Parfait pour le stockage de sessions
  - Support des structures de donn√©es complexes

- **Jest**
  - Framework de test complet
  - Support du code coverage
  - Mocking int√©gr√©

#### Fonctionnalit√©s Impl√©ment√©es

Notre API offre un ensemble complet de fonctionnalit√©s :

1. **API REST CRUD**
   - Endpoints bien document√©s
   - Validation des donn√©es avec Joi
   - Gestion des erreurs standardis√©e

2. **Validation des Donn√©es**
   - Sch√©mas de validation stricts
   - Messages d'erreur clairs
   - Sanitization des inputs

3. **Gestion des Erreurs**
   - Middleware d'erreur centralis√©
   - Codes HTTP appropri√©s
   - Messages d'erreur d√©taill√©s

4. **Monitoring**
   - Endpoint de health check
   - M√©triques de performance
   - Logs structur√©s

#### Tests Approfondis

Nous avons mis l'accent sur la qualit√© du code avec une suite de tests compl√®te :

1. **Tests Unitaires**
   - Tests des op√©rations Redis
   - Validation des mod√®les
   - Helpers et utilitaires

2. **Tests d'Int√©gration**
   - Tests end-to-end des endpoints
   - Sc√©narios complexes
   - Tests de charge

3. **Tests de Configuration**
   - Validation des variables d'environnement
   - Tests de connexion Redis
   - Tests de middleware

4. **Couverture de Code**
   - Objectif > 80% atteint
   - Rapports d√©taill√©s
   - Int√©gration CI/CD

#### üì∏ Captures d'√©cran

| Fonctionnalit√© | Description | Capture |
|----------------|-------------|----------|
| Tests | Ex√©cution des tests unitaires et d'int√©gration | [üì∑](./image/1-app-web/npm_test.png) |
| Cr√©ation | Ajout d'un nouvel utilisateur | [üì∑](./image/1-app-web/api_create.png) |
| Lecture | R√©cup√©ration des d√©tails d'un utilisateur | [üì∑](./image/1-app-web/api_get.png) |
| Mise √† jour | Modification des informations utilisateur | [üì∑](./image/1-app-web/api_update.png) |
| Suppression | Suppression d'un utilisateur | [üì∑](./image/1-app-web/api_delete.png) |
| Health Check | V√©rification de l'√©tat de l'application | [üì∑](./image/1-app-web/health_check.png) |

### 2. CI/CD Pipeline

Notre pipeline CI/CD, construit avec GitHub Actions, automatise l'int√©gration et le d√©ploiement de notre application.

#### Configuration GitHub Actions

```yaml
name: CI/CD Pipeline
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install Dependencies
        run: npm ci
      - name: Run Tests
        run: npm test
```

#### √âtapes du Pipeline

Notre pipeline suit un processus en plusieurs √©tapes :

1. **Installation et Configuration**
   - Setup de l'environnement Node.js
   - Installation des d√©pendances
   - Configuration de Redis pour les tests

2. **Phase de Test**
   - Linting avec ESLint
   - Tests unitaires
   - Tests d'int√©gration
   - G√©n√©ration des rapports

3. **Build Docker**
   - Construction de l'image
   - Tests de l'image
   - Push vers Docker Hub

4. **D√©ploiement**
   - D√©ploiement sur Heroku
   - Tests de smoke
   - V√©rification du d√©ploiement

#### üì∏ Captures d'√©cran

| √âtape | Description | Capture |
|-------|-------------|----------|
| GitHub Actions | Pipeline d'int√©gration continue | [üì∑](./image/2-ci-cd/github_actions.png) |
| D√©ploiement | D√©ploiement r√©ussi sur Heroku | [üì∑](./image/2-ci-cd/heroku_deployment.png) |

### 3. Infrastructure as Code

Notre infrastructure est enti√®rement g√©r√©e par code, utilisant Vagrant pour la virtualisation et Ansible pour le provisioning.

#### Configuration Vagrant

Notre Vagrantfile configure une VM Ubuntu optimis√©e :

```ruby
Vagrant.configure("2") do |config|
  config.vm.box = "ubuntu/focal64"
  
  # Configuration syst√®me
  config.vm.provider "virtualbox" do |vb|
    vb.memory = "2048"
    vb.cpus = 2
  end

  # Networking
  config.vm.network "forwarded_port", guest: 3000, host: 3000
  
  # Shared folders
  config.vm.synced_folder ".", "/vagrant_data"
  
  # Provisioning
  config.vm.provision "ansible" do |ansible|
    ansible.playbook = "playbook.yml"
  end
end
```

Cette configuration :
- Utilise Ubuntu 20.04 LTS
- Alloue 2GB de RAM et 2 CPU
- Configure le port forwarding
- Monte les dossiers partag√©s
- Int√®gre Ansible pour le provisioning

#### Ansible Playbooks

Notre configuration Ansible est organis√©e en plusieurs playbooks :

1. **Installation Syst√®me**
   ```yaml
   - name: System Setup
     hosts: all
     tasks:
       - name: Update apt cache
         apt: update_cache=yes
       - name: Install system dependencies
         apt:
           name: "{{ item }}"
           state: present
         with_items:
           - curl
           - git
           - build-essential
   ```

2. **Configuration Node.js**
   ```yaml
   - name: Node.js Setup
     hosts: all
     tasks:
       - name: Add NodeSource repository
         shell: |
           curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -
       - name: Install Node.js
         apt:
           name: nodejs
           state: present
   ```

3. **Configuration Redis**
   ```yaml
   - name: Redis Setup
     hosts: all
     tasks:
       - name: Install Redis
         apt:
           name: redis-server
           state: present
       - name: Start Redis
         service:
           name: redis-server
           state: started
           enabled: yes
   ```

#### üì∏ Captures d'√©cran

| Composant | Description | Capture |
|-----------|-------------|----------|
| Vagrant | √âtat de la machine virtuelle | [üì∑](./image/3-iac/vagrant_status.png) |
| Ansible | R√©sultat du provisioning | [üì∑](./image/3-iac/ansible_provisioning.png) |
| Application | Acc√®s √† l'application via port forwarding | [üì∑](./image/3-iac/app_acces.png) |

### 4. Docker

Notre configuration Docker est optimis√©e pour la production avec un build multi-stage.

#### Dockerfile Optimis√©

```dockerfile
# Build stage
FROM node:14-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .

# Production stage
FROM node:14-alpine
WORKDIR /app
COPY --from=builder /app ./
EXPOSE 3000
CMD ["npm", "start"]
```

#### Optimisations Impl√©ment√©es

1. **Multi-stage Build**
   - S√©paration des √©tapes de build
   - R√©duction de la taille finale
   - Optimisation des layers

2. **Base Alpine**
   - Image l√©g√®re
   - S√©curit√© renforc√©e
   - Performance optimale

3. **Configuration**
   - .dockerignore optimis√©
   - Variables d'environnement
   - Gestion des secrets

#### üì∏ Captures d'√©cran

| √âtape | Description | Capture |
|-------|-------------|----------|
| Build | Construction de l'image Docker | [üì∑](./image/4-docker-image/build.png) |
| Registry | Image publi√©e sur Docker Hub | [üì∑](./image/4-docker-image/dockerHub.png) |
| Push | Publication de l'image | [üì∑](./image/4-docker-image/push.png) |
| Test | Test local de l'image | [üì∑](./image/4-docker-image/runLocal.png) |
| Validation | V√©rification du fonctionnement | [üì∑](./image/4-docker-image/runValide.png) |

### 5. Docker Compose

Notre configuration Docker Compose orchestre plusieurs services en local.

#### Configuration D√©taill√©e

```yaml
version: '3.8'
services:
  api:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
  
  redis:
    image: redis:alpine
    volumes:
      - redis_data:/data
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  redis_data:
```

#### Services Configur√©s

1. **API Node.js**
   - Build depuis Dockerfile local
   - Variables d'environnement configur√©es
   - Healthcheck int√©gr√©
   - Red√©marrage automatique

2. **Redis**
   - Image officielle Alpine
   - Persistance des donn√©es
   - Configuration optimis√©e
   - R√©seau d√©di√©

#### üì∏ Captures d'√©cran

| √âtape | Description | Capture |
|-------|-------------|----------|
| Build | Construction des services | [üì∑](./image/5-docker-compose/build.png) |
| Push | Publication sur Docker Hub | [üì∑](./image/5-docker-compose/push.png) |
| Registry | Image sur Docker Hub | [üì∑](./image/5-docker-compose/dockerHub.png) |
| D√©marrage | Lancement des services | [üì∑](./image/5-docker-compose/docker-compose-up.png) |
| Services | Services en cours d'ex√©cution | [üì∑](./image/5-docker-compose/serveur-running.png) |
| Test API | Test avec curl | [üì∑](./image/5-docker-compose/curlSnippet.png) |
| Cr√©ation | Ajout d'un utilisateur | [üì∑](./image/5-docker-compose/creationUserCurl.png) |
| V√©rification | Confirmation de la cr√©ation | [üì∑](./image/5-docker-compose/verificationUserCreation.png) |

### 6. Kubernetes

Notre d√©ploiement Kubernetes est configur√© pour la haute disponibilit√© et la scalabilit√©.

#### 1. üåü Installer Minikube et d√©marrer le cluster
> Action : Initialisation de l'environnement Kubernetes local

#### üö¶ D√©marrer le cluster Minikube

```bash
# D√©marre un cluster Kubernetes local avec les param√®tres par d√©faut
# Cette commande initialise un environnement Kubernetes mononode sur votre machine
minikube start
```

[Voir le r√©sultat](./image/6-K8/minikube-start.png)

#### ‚úÖ V√©rifier le cluster

```bash
# Affiche les informations sur le cluster Kubernetes en cours d'ex√©cution
kubectl cluster-info
```

[Voir la sortie du cluster-info](./image/6-K8/cluster-info.png)

---

#### 2. üê≥ Dockeriser l'application
> Action : Pr√©paration des conteneurs pour le d√©ploiement

#### üèóÔ∏è Construire les images Docker

```bash
# Construit l'image Docker pour l'API utilisateur
docker build -t quentinc123/userapi:latest .

# Construit l'image Docker pour Redis
docker build -t redis:latest .
```

[Voir le processus de build Docker](./image/6-K8/docker-build.png)
[Voir le processus de build Docker pour Redis](./image/6-K8/docker-build-redis.png)

---

#### 3. üìù Cr√©er les manifestes Kubernetes
> Action : Configuration des ressources Kubernetes n√©cessaires

Cr√©ation des fichiers YAML Kubernetes pour d√©finir les d√©ploiements et services.

#### `redis-deployment.yaml`

Ce fichier d√©finit le d√©ploiement et le service pour le service `redis`.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:latest
        ports:
        - containerPort: 6379
```

#### `redis-service.yaml`

Ce fichier d√©finit le service pour le service `redis`.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: redis-service
spec:
  selector:
    app: redis
  ports:
    - protocol: TCP
      port: 6379
  clusterIP: None
```

#### `userapi-deployment.yaml`

Ce fichier d√©finit le d√©ploiement pour le service `userapi`.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: userapi-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: userapi
  template:
    metadata:
      labels:
        app: userapi
    spec:
      containers:
      - name: userapi-container
        image: quentinc123/userapi:latest
        ports:
        - containerPort: 3000
        env:
        - name: REDIS_HOST
          value: redis-service
```

#### `userapi-service.yaml`

Ce fichier d√©finit le service pour le service `userapi`.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: userapi-service
spec:
  selector:
    app: userapi
  ports:
    - protocol: TCP
      port: 3000
  clusterIP: None
```

#### Volume persistant et r√©clamation pour Redis

Cr√©ation les fichiers suivants pour le volume persistant et la r√©clamation.

**`redis-pv.yaml`** :

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: redis-pv
spec:
  capacity:
    storage: 1Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /mnt/data/redis
```

**`redis-pvc.yaml`** :

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: redis-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

---

#### 4. ‚öôÔ∏è Appliquer les manifestes Kubernetes
> Action : D√©ploiement des services dans le cluster

```bash
# Cr√©e le volume persistant pour Redis
# Permet de conserver les donn√©es m√™me apr√®s un red√©marrage
kubectl apply -f redis-pv.yaml

# Cr√©e la r√©clamation de volume persistant
# Lie le volume persistant √† Redis
kubectl apply -f redis-pvc.yaml

# D√©ploie Redis avec la configuration sp√©cifi√©e
# Cr√©e un pod Redis avec stockage persistant
kubectl apply -f redis-deployment.yaml

# Expose Redis comme un service dans le cluster
# Permet aux autres pods de communiquer avec Redis
kubectl apply -f redis-service.yaml

# D√©ploie l'API utilisateur
# Cr√©e les pods pour l'application userapi
kubectl apply -f userapi-deployment.yaml

# Expose l'API utilisateur comme un service
# Permet d'acc√©der √† l'API depuis l'ext√©rieur du cluster
kubectl apply -f userapi-service.yaml
```

[Voir le d√©ploiement des manifestes](./image/6-K8/manifests-deployment.png)

---

#### 5. üîç V√©rifier les d√©ploiements
> Action : Validation de l'√©tat des services d√©ploy√©s

```bash
# Liste tous les pods en cours d'ex√©cution
# V√©rifie que les pods sont en √©tat 'Running'
kubectl get pods

# Liste tous les services actifs
# Montre les points d'acc√®s des applications
kubectl get services

# Liste tous les d√©ploiements
# Affiche le nombre de r√©pliques et leur √©tat
kubectl get deployments
```

[Voir l'√©tat des d√©ploiements](./image/6-K8/deployment-status.png)

---

#### 6. üß™ Tester les services
> Action : Test de l'accessibilit√© des services d√©ploy√©s

```bash
# Transf√®re le port 3000 du service vers localhost
# Permet d'acc√©der √† l'API depuis votre machine locale
kubectl port-forward service/userapi-service 3000:3000
```

[Voir l'interface utilisateur en action](./image/6-K8/userapi-interface.png)

---

#### 7. üîÑ Red√©marrer les d√©ploiements
> Action : Mise √† jour des services en cours d'ex√©cution

```bash
# Red√©marre le d√©ploiement de l'API utilisateur
kubectl rollout restart deployment/userapi-deployment

# Red√©marre le d√©ploiement Redis
kubectl rollout restart deployment/redis-deployment
```

[Voir le red√©marrage des d√©ploiements](./image/6-K8/deployment-restart.png)

---

#### 8. üßπ Nettoyer les ressources
> Action : Suppression propre des ressources cr√©√©es

```bash
# Supprime le volume persistant Redis
# Lib√®re l'espace de stockage allou√©
kubectl delete -f redis-pv.yaml

# Supprime la r√©clamation de volume persistant
# Nettoie la demande de stockage
kubectl delete -f redis-pvc.yaml

# Supprime le d√©ploiement Redis
# Arr√™te tous les pods Redis
kubectl delete -f redis-deployment.yaml

# Supprime le d√©ploiement de l'API utilisateur
# Arr√™te tous les pods de l'API
kubectl delete -f userapi-deployment.yaml
```

[Voir le nettoyage des ressources](./image/6-K8/cleanup.png)

---

### üåê 7. Service Mesh avec Istio

#### üöÄ Installation

#### 1Ô∏è‚É£ Installation d'Istio
```bash
# T√©l√©charger et installer Istio
istioctl install --set profile=demo -y

# Activer l'injection automatique de sidecar Istio
kubectl label namespace default istio-injection=enabled
```

[üì∏ Voir la capture d'√©cran](./image/7-istio/istio-injection.png)

### 2Ô∏è‚É£ V√©rification
```bash
istioctl verify-install
```

[üì∏ Voir la capture d'√©cran de la v√©rification de l'installation](./image/7-istio/istio-install.png)

#### ‚öôÔ∏è Configuration du Routage

#### üîÑ VirtualService
Fichier: `userapi-virtualservice.yaml`
```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: userapi-virtualservice
spec:
  hosts:
  - "*"
  gateways:
  - userapi-gateway
  http:
  - route:
    - destination:
        host: userapi-service
        subset: v1
      weight: 50
    - destination:
        host: userapi-service
        subset: v2
      weight: 50
```

#### üéØ DestinationRule
Fichier: `userapi-destinationrule.yaml`
```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: userapi-destinationrule
spec:
  host: userapi-service
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
```

#### üö™ Gateway
Fichier: `userapi-gateway.yaml`
```yaml
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: userapi-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 3000
      name: http
      protocol: HTTP
    hosts:
    - "*"
```

#### üîç V√©rification

#### 1Ô∏è‚É£ V√©rifier les Services Istio
```bash
kubectl get svc -n istio-system
```
[üì∏ Voir la capture d'√©cran des services Istio](./image/7-istio/istio-running.png)

#### 2Ô∏è‚É£ V√©rifier la Configuration
```bash
kubectl get gateway
kubectl get destinationrules
kubectl get virtualservices 
```

[üì∏ Voir la capture d'√©cran des VirtualServices et DestinationRules](./image/7-istio/istio-check.png)

#### üß™ Test de l'Application

#### 1Ô∏è‚É£ Obtenir l'IP du Gateway
```bash
kubectl get svc -n istio-system
```
[üì∏ Voir la capture d'√©cran de la v√©rification de l'installation](./image/7-istio/istio-getsvc.png)

#### 2Ô∏è‚É£ Tester les Routes
```bash
curl http://<external-ip>/v1
curl http://<external-ip>/v2
```

[üñºÔ∏è Voir la capture d'√©cran du test de l'application](./image/7-istio/)

## üìÅ Structure du Projet

Notre projet suit une structure modulaire et organis√©e :

```
.
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/          # Configuration CI/CD
‚îú‚îÄ‚îÄ userapi/
‚îÇ   ‚îú‚îÄ‚îÄ src/               # Code source de l'application
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/   # Logique m√©tier
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/       # Mod√®les de donn√©es
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/       # D√©finition des routes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/        # Utilitaires
‚îÇ   ‚îú‚îÄ‚îÄ test/             # Tests
‚îÇ   ‚îú‚îÄ‚îÄ package.json      # D√©pendances
‚îÇ   ‚îî‚îÄ‚îÄ CHANGELOG.md      # Journal des modifications
‚îú‚îÄ‚îÄ iac/
‚îÇ   ‚îú‚îÄ‚îÄ Vagrantfile       # Configuration VM
‚îÇ   ‚îî‚îÄ‚îÄ playbooks/        # Playbooks Ansible
‚îú‚îÄ‚îÄ k8s/                  # Manifestes Kubernetes
‚îú‚îÄ‚îÄ istio/                # Configuration Istio
‚îú‚îÄ‚îÄ image/                # Screenshots
‚îî‚îÄ‚îÄ docker-compose.yaml   # Orchestration Docker
```

## üîó Liens

- [Repository GitHub](https://github.com/Vincent23032003/devops-project-2024)
- [Image Docker Hub](https://hub.docker.com/r/vincennnt/userapi)
- [Application Heroku](https://devops-userapi-2024-671a8bceceee.herokuapp.com/)
- [Documentation officielle Kubernetes](https://kubernetes.io/docs/)
- [Documentation Minikube](https://minikube.sigs.k8s.io/docs/)
- [Guide des meilleures pratiques Kubernetes](https://kubernetes.io/docs/concepts/configuration/overview/)

## üë• Auteurs

- **Vincent BAR√â** - Cyber Gr 01
  - CI/CD Pipeline
  - Docker

- **Louis DECOURTIS** - Cyber Gr 01
  - D√©veloppement API
  - Tests automatis√©s
  - Documentation

- **Quentin CARMINOT** - Cyber Gr 01
  - Configuration Kubernetes
  - Int√©gration Istio

_Projet r√©alis√© dans le cadre du cours DevOps √† l'ECE Paris_
